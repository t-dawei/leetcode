#《《链表问题总结》》
---
#输出单链表倒数第K个结点
两次遍历：
- O(n*n)
- 简单但效率低下

递归法：
- O(n*n)
- 使用递归遍历至末尾，由末尾开始返回，每返回一次num-1,当num为0时，即目标结点

双指针法：
<br>
（1）定义两个指针 p1 和 p2 分别指向链表头节点。
（2）p1 前进 K 个节点，则 p1 与 p2 相距 K 个节点。
（3）p1，p2 同时前进，每次前进 1 个节点。
（4）当 p1 指向到达链表末尾，由于 p1 与 p2 相距 K 个节点，则 p2 指向目标节点
<br>
- O(n)
- [示例:输出单链表倒数第K个结点](https://github.com/t-dawei/leetcode/blob/master/code/19.%20删除链表的倒数第N个节点.py)

===
# 判断链表是否有环
穷举比较法：
- O(n^2)
哈希缓存法：
（1）首先创建一个以节点 ID 为键的 HashSe t集合，用来存储曾经遍历过的节点。
（2）从头节点开始，依次遍历单链表的每一个节点。
（3）每遍历到一个新节点，就用新节点和 HashSet 集合当中存储的节点作比较，如果发现 HashSet 当中存在相同节点 ID，则说明链表有环，如果 HashSet 当中不存在相同的节点 ID，就把这个新节点 ID 存入 HashSet ，之后进入下一节点，继续重复刚才的操作。
快慢指针法
（1）定义两个指针分别为 slow，fast，并且将指针均指向链表头节点。
（2）规定，slow 指针每次前进 1 个节点，fast 指针每次前进两个节点。
（3）当 slow 与 fast 相等，且二者均不为空，则链表存在环。
===
# 定位环入口
slow 指针每次前进一个节点，故 slow 与 fast 相遇时，slow 还没有遍历完整个链表。设 slow 走过节点数为 s，fast 走过节点数为 2s。设环入口点距离头节点为 a，slow 与 fast 首次相遇点距离入口点为 b，环的长度为 r。
则有：
s = a + b;
2s = n * r + a + b; n 代表fast指针已经在环中循环的圈数。
则推出：
s = n * r; 意味着slow指针走过的长度为环的长度整数倍。

若链表头节点到环的末尾节点度为 L，slow 与 fast 的相遇节点距离环入口节点为 X。
则有：
a+X = s = n * r = (n - 1) * r + (L - a);
a = (n - 1) * r + (L - a - X);
上述等式可以看出：
从 slow 与 fast 相遇点出发一个指针 p1，请进 (L - a - X) 步，则此指针到达入口节点。同时指针 p2 从头结点出发，前进 a 步。当 p1 与 p2 相遇时，此时 p1 与 p2 均指向入口节点。

# 计算环长度
在3.1中找到了 slow 与 fast 的相遇节点，令 solw 与 fast 指针从相遇节点出发，按照之前的前进规则，当 slow 与fast 再次相遇时，slow 走过的长度正好为环的长度。

# 使用链表实现大数加法
两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。

# 有序链表合并
（1）对空链表存在的情况进行处理，假如 pHead1 为空则返回 pHead2 ，pHead2 为空则返回 pHead1。（两个都为空此情况在pHead1为空已经被拦截）
（2）在两个链表无空链表的情况下确定第一个结点，比较链表1和链表2的第一个结点的值，将值小的结点保存下来为合并后的第一个结点。并且把第一个结点为最小的链表向后移动一个元素。
（3）继续在剩下的元素中选择小的值，连接到第一个结点后面，并不断next将值小的结点连接到第一个结点后面，直到某一个链表为空。
（4）当两个链表长度不一致时，也就是比较完成后其中一个链表为空，此时需要把另外一个链表剩下的元素都连接到第一个结点的后面。

# 删除链表中节点，要求时间复杂度为O(1)
示例 
单链表：1->2->3->4->NULL 
若要删除节点 3 。第一步将节点3的下一个节点的值4赋值给当前节点。变成 1->2->4->4->NULL，然后将就 4 这个结点删除，就达到目的了。 1->2->4->NULL

# 从尾到头打印链表
栈 
递归

# 反转链表
设置三个节点pre、cur、next

（1）每次查看cur节点是否为NULL，如果是，则结束循环，获得结果
（2）如果cur节点不是为NULL，则先设置临时变量next为cur的下一个节点
（3）让cur的下一个节点变成指向pre，而后pre移动cur，cur移动到next
（4）重复（1）（2）（3）